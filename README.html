<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>kexec-loader manual</title>
<style type="text/css">
<!--
body {
font-family: Arial, Helvetica, sans-serif;
}
h1 {
font-size: xx-large;
color: #0099FF;
}
h2 {
color: #0066FF;
}
h3 {
color: #0033CC;
}
a {
text-decoration: none;
color: blue;
}
a:hover {
color: red;
}
-->
</style>
</head>

<body>
<h1>kexec-loader manual</h1>
<p>Version: 1.6</p>
<p>&copy; 2008 Daniel Collins<br />&copy; 2008 Philip Kent</p>

<h2>1. Compilation</h2>
<h3>1.1. Introduction</h3>
<p>kexec-loader is a boot loader which loads a Linux kernel, then displays a GRUB-like menu so you can select a kernel to boot
using kexec. It is designed for systems where the BIOS does not support booting from some devices (e.g. your kernel is on a USB memory key which the BIOS does not support).</p>
<p>If you have downloaded one of the pre-built disk images, you do not need to read the rest of this section, and you can skip to Section 2. A pre-made disk image is probably more suitable to the end user in most cases, as the provided image supports IDE, SATA and USB and is pre-compiled. You can obtain it from the project's webpage.</p>
<h3>1.2. New in kexec-loader 1.6</h3>
<p>A summary of the new features in this release of kexec-loader is below. For a more detailed changelog, please see the ChangeLog file.</p>
<ul>
<li>Upgraded kexec-tools to version 2.0.0</li>
<li>Updated console code to work on serial consoles</li>
<li>Rewrote shell input code for better line editing</li>
<li>Changed module loading behaviour</li>
</ul>
<h3>1.3. Requirements</h3>
<p>To build kexec-loader, you require the following tools.</p>
<ul>
  <li>gcc C compiler</li>
  <li>bourne shell</li>
  <li>make</li>
  <li>binutils</li>
  <li>coreutils</li>
  <li>cpio</li>
  <li>wget</li>
  <li><i>Optional but highly recommended:</i> uclibc toolchain</li>
  <li>A bootloader (such as syslinux)</li>

</ul>
<p>kexec-tools is included and built as part of the build process.</p>
<h3>1.4. Build Instructions</h3>
<p>In order to build kexec-loader, you first need a Linux kernel with support for the hardware you want to boot from. This kernel will need fit onto the device that will be used to boot, with sufficient space left for other files that will need to be on the device (such as kexec-loader itself and the boot loader).</p>
<p>Once you have your kernel, simply run "make" from the root of the kexec-loader source to build the kexec-loader binary. This will include downloading and building kexec-tools. It is recommended that you build a uclibc toolchain prior to this, then building kexec-loader using it, as this will make the resulting file smaller. To use a uclibc toolchain, do "HOST=i386-linux-uclibc make" instead of make.</p>
<p>Then run mkinitramfs.sh from the root directory of the distribution to build an initramfs containing kexec-loader.</p>
<h3>1.5. Creating a Disk Image</h3>
<p>Once you have a kernel and initramfs, you can then build a disk image. There are two ways to assemble the disk, which are below.</p>
<ol>
<li>Embed your initramfs inside your kernel (this is what is done by the prebuilt images) using menuconfig. You will have to rebuild your kernel.</li>

<li>Just load it as an initramfs along with your kernel with a boot loader.</li>
</ol>
<p>Regardless of the method you choose, you will need a bootloader such as syslinux. Build your image using your favourite method (such as using dd to produce an empty floppy image, formatting it then loop mounting it), put the kernel and initramfs (if any) on the disk, along with any boot loader configuration, install the boot loader and your disk is prepared.</p>
<h2>2. Usage</h2>
<h3>2.1. Configuration File</h3>
<p>
kexec-loader uses a simple configuration file to store target kernels and settings.
If you have downloaded one of the pre-made disk images, a sample configuration
is included which might be able to boot a Debian system.
</p>
<p>kexec-loader will attempt to find a configuration in the following places in order:</p>
<ul>
	<li>/dev/fd0</li>
	<li>/dev/fd1</li>
	<li>/dev/sda</li>
	<li>/dev/sdb</li>
	<li>/dev/scd</li>
	<li>/dev/sdd</li>
</ul>
<p>
You can insert a device at the beginning of this list by passing kexec_config=/dev/foo
to the kexec-loader kernel at boot.
</p>

<p>
The configuration must be called kexec-loader.conf and should be stored in the
root of the kexec-loader boot disk. Configuration directives and their arguments
should be seperated by spaces/tabs, empty lines and lines beginning with a hash
(#) are ignored.
</p>
<p>The directives are as follows.</p>
<ul>
	<li><b>timeout &lt;integer&gt;</b><br />
	Amount of seconds to wait till the kernel marked default is loaded. If
	no kernel is marked as default, the first kernel in the list will be
	loaded. If this is omitted, and a grub config file is loaded, it will
	use the timeout from there (otherwise it will not timeout).
	</li>
	<li><b>title &lt;text&gt;</b><br />
	Title of the entry. This starts an item on the list, and all following
	directives will be processed as a part of this entry until the next
	title directive.
	</li>
	<li><b>kernel &lt;filename&gt;</b><br />
	Filename of the kernel in the rootfs (see below).
	</li>
	<li><b>initrd &lt;filename&gt;</b><br />
	As above but for the initrd.
	</li>
	<li><b>cmdline &lt;string&gt;</b><br />
	Set the command line which will be passed to the target kernel.
	</li>
	<li><b>append &lt;string&gt;</b><br />
	Set the kernel command line using --append, this appears to do exactly
	the same thing as cmdline, but is implemented for completeness.
	</li>
	<li><b>rootfs [fstype:]&lt;device&gt;</b><br />
	Device to mount as / so as to find the kernel and initrd to load.
	</li>
	<li><b>mount [fstype:]&lt;device&gt;  &lt;mountpoint&gt;</b><br />
	Device to mount at a certain mountpoint. This is not for filesystems to
	load under the new kernel, just any other filesystems that may be needed
	to start the new kernel running (e.g. if the initrd is stored on another
	filesystem).
	</li>
	<li><b>default</b><br />
	Make this kernel the default kernel to boot  if the timeout expires.
	</li>
	<li><b>grub_root [fstype:]&lt;device&gt;</b><br />
	Load menu.lst and device.map from a GRUB installation, GRUB should
	either be installed to /boot/grub/ or /grub/ on the selected device.
	</li>
	<li><b>grub_first &lt;hdx/sdx&gt;</b><br />
	Default is hdx. If hdx is specified, (hd0) will be hda, then all devices
	will follow as normal, with sd devices following at the end. If it's
	sdx, then it will reverse, (hd0) will be sda, followed by all other sd
	devices, then hd devices following at the end. <b>If a device.map was
	found:</b> kexec-loader will attempt to load settings from this, before
	failing back to this directive.
	</li>
	<li><b>reset-vga</b><br />
	Reset the VGA adaptor before starting the kernel, may be useful if you get garbled or no output on bootup.
	</li>
	<li><b>module &lt;filename&gt; [&lt;args&gt;]</b><br />
	Load a multiboot module for the target kernel.
	</li>
</ul>
<p>Where parameters are shown in &lt;angled brackets&gt;, they are required for that directive. Ones in [square brackets] are optional. For mount and rootfs, if you do specify a fstype, it should be specified as ext2:/dev/hda1 for example.</p>

<p>Normally kexec-loader can detect the filesystem type, it supports autodetection for the following types.</p>
<ul>
  <li>ext2</li>
  <li>ext3</li>
  <li>XFS</li>
  <li>reiserfs</li>
  <li>Minix</li>

  <li>FAT</li>
  <li>NTFS</li>
  <li>ISO-9660 (aka CD-ROM)</li>
</ul>
<p>Specifying no filesystem or "auto" will result in auto detection. For manual specification, enter the name of any filesystem that your kernel supports.</p>
<h3>2.2. Using the Menu</h3>
<p>To navigate the kexec-loader menu, use your arrow keys to select an item and press enter to boot it. A number of functions are available; press L to list the detected devices and their filesystems. Press enter if you are on the device screen or an error and you want to escape.</p>
<p>Upon asking a kernel to boot, it may take a few seconds for it to load the kernel and switch to it. After switching, your new kernel will start and the boot process will happen as it would normally.</p>

<h3>2.3. Built in shell</h3>
<p>kexec-loader has a built in shell. To access it press "s" on the menu screen. This shell allows </p>
<p>There are two further directives used to control kexec-loader, rather than set up a kernel to boot. They are:</p>
<ul>
	<li><b>mount [fstype:]&lt;device&gt; &lt;mount point&gt;</b><br />
	Mount a device, if fstype is ommited, kexec-loader will attempt to autodetect the format.
	</li>
	<li><b>module &lt;filename&gt; [args]</b><br />
	Load a multiboot module for the target kernel.
	</li>
	<li><b>kernel &lt;filename&gt;</b><br />
	Set the kernel filename.
	</li>
	<li><b>initrd [filename]</b><br />
	Set the initrd/initramfs filename.
	</li>
	<li><b>cmdline [string]</b><br />
	Set the command line which will be passed to the target kernel.
	</li>
	<li><b>append [string]</b><br />
	Set the command kernel line using --append, this appears to do exactly the same thing
	as cmdline, but is implemented for completeness.
	</li>
	<li><b>reset-vga</b><br />
	Enable the --reset-vga option, which fixes some graphics problems.
	</li>
	<li><b>disks</b><br />
	Display a list of disks and partitions which have been detected by Linux.
	</li>
	<li><b>cd [directory]</b><br />
	Change the current working directory, if directory is ommited, / will be used.
	</li>
	<li><b>ls [directory]</b><br />
	List the contents of a directory, if directory is ommited, the current directory will be used.
	</li>
	<li><b>find &lt;filename&gt; [directory]</b><br />
	Search for files matching the pattern 'filename', filename may include the wildcard characters * or ?, if
	directory is ommited, the current directory will be searched.
	</li>
	<li><b>exit</b>
	<br />Leave the shell and go back to the menu.
	</li>
</ul>
<p>To scroll through the command history, use the up and down keys. A maximum of 32 commands are remembered (upon exceeding this, the oldest command will be removed from the history to make space). Commands that are longer than the screen can hold will scroll, similar to the 'nano' text editor. Please note that this shell will be improved in subsequent releases.</p>

<h3>2.4. Debug Console</h3>
<p>
Once kexec-loader has started all debugging messages, as well as Linux kernel
messages are sent to a separate debug console. By default the debug console is
/dev/tty2, this can be changed at boot by using the Linux cmdline, for example
kexec_debug=/dev/ttyS0 writes all debug messages and kernel messages to the
first serial port.
</p>

<h3>2.5 Kernel Modules</h3>
<p>
Kernel modules can be loaded by kexec-loader to add support for extra devices or
filesystems which target systems can be loaded from. To add extra modules, simply
copy them to /modules/ on the kexec-loader disk, to specify module arguments, use
the /modules/modules.conf file. Modules loaded this way only affect the kernel
running kexec-loader, not those loaded by kexec-loader.
</p>

<h2>3. Support</h2>
<h3>3.1. Website</h3>
<p>For information on kexec-loader, including current development and latest releases, please see its website at <a href="http://www.solemnwarning.net">http://www.solemnwarning.net</a>.</p>

<h3>3.2. Mailing List</h3>
<p>A mailing is available for kexec-loader, subscription information and archives can be found at <a href="http://www.solemnwarning.net/kexec-loader/list">http://www.solemnwarning.net/kexec-loader/list</a>.</p>
<h3>3.3. Developer</h3>
<p>The developer of kexec-loader, Daniel Collins (aka solemnwarning), can often be found on the Freenode IRC network. To contact solemnwarning, you can use the following e-mail address: <em>solemnwarning@solemnwarning.net</em>.</p>
</body>
</html>
